#!/usr/bin/env node

import { Shell } from './shell.js';
import { HttpClient } from './http/http-client.js';
import { StringUtil } from './utils/string-util.js';
import { GitService, GitFileStatus } from './services/git-service.js';
import { OpenAiService } from './services/openai-service.js';
import { GitPlatformServiceFactory, GitPlatformService, getGitAccessTokenForCurrentRepo } from './services/git-platform-service.js';
import { WecomNotifier } from './services/wecom-notifier.js';
import { configLoader, parseCliArgs, getConfigValue, getCliHelp, LoadedConfig, initConfig } from './config.js';
import path from 'path';
import { fileURLToPath } from 'url';
import clipboard from 'clipboardy';
import readline from 'readline';

/**
 * Base class for AI-powered Git automation applications
 */
export abstract class BaseAiflowApp {
  protected readonly shell = new Shell();
  protected readonly http = new HttpClient();
  protected readonly git = new GitService(this.shell);

  protected config!: LoadedConfig;
  protected openai!: OpenAiService;
  protected gitPlatform!: GitPlatformService;
  protected wecom!: WecomNotifier;

  /**
   * Initialize services with configuration
   */
  protected async initializeServices(cliConfig: any = {}): Promise<void> {
    // Load configuration with priority merging
    this.config = await configLoader.loadConfig(cliConfig);

    // Initialize services with configuration
    this.openai = new OpenAiService(
      getConfigValue(this.config, 'openai.key', '') || '',
      getConfigValue(this.config, 'openai.baseUrl', 'https://api.openai.com/v1') || 'https://api.openai.com/v1',
      getConfigValue(this.config, 'openai.model', 'gpt-3.5-turbo') || 'gpt-3.5-turbo',
      this.http
    );

    // Create platform-specific service using factory (fully automatic)
    const platformService = await GitPlatformServiceFactory.create();

    if (!platformService) {
      throw new Error('Unsupported Git platform. Currently supported: GitLab, GitHub');
    }

    this.gitPlatform = platformService;

    this.wecom = new WecomNotifier(
      getConfigValue(this.config, 'wecom.webhook', '') || ''
    );

    // Display configuration warnings
    const warnings = configLoader.getWarnings();
    if (warnings.length > 0) {
      console.log('\n‚ö†Ô∏è  Configuration warnings:');
      warnings.forEach(warning => console.log(`  ${warning}`));
      console.log('');
    }
  }

  /**
   * Get target branch for merge request (default branch or fallback)
   * @returns Target branch name
   */
  protected getTargetBranch(): string {
    try {
      // Try to get the default branch from git remote
      const currentBranch = this.git.getCurrentBranch();
      try {
        this.shell.run(`git rev-parse --verify origin/${currentBranch}`).trim();
        return currentBranch;
      } catch (fallbackError) {
        console.warn(`‚ö†Ô∏è  Could not determine target branch, check: ${fallbackError}`);
      }

      // Common default branch names to try
      const defaultBranches = ['main', 'master', 'develop'];

      // If current branch is one of the default branches, use it
      if (defaultBranches.includes(currentBranch)) {
        return currentBranch;
      }

      // Otherwise, try to find the default branch by checking which exists
      for (const branch of defaultBranches) {
        try {
          // Check if remote branch exists
          this.shell.run(`git rev-parse --verify origin/${branch}`);
          return branch;
        } catch {
          // Branch doesn't exist, try next
        }
      }

      // Fallback to main if nothing else works
      return 'main';
    } catch (error) {
      console.warn(`‚ö†Ô∏è  Could not determine target branch, using 'main': ${error}`);
      return 'main';
    }
  }

  /**
   * Interactive file selection for staging
   * @returns Promise<boolean> - true if files were staged, false if user cancelled
   */
  protected async interactiveFileSelection(): Promise<boolean> {
    const fileStatuses = this.git.status();
    
    if (fileStatuses.length === 0) {
      console.log("‚úÖ No changes detected in the repository.");
      return false;
    }

    console.log('\nüìÅ Detected file changes:');
    console.log('‚îÄ'.repeat(50));
    
    // Group files by status for better display
    const untracked = fileStatuses.filter(f => f.isUntracked);
    const modified = fileStatuses.filter(f => !f.isUntracked && f.workTreeStatus === 'M');
    const deleted = fileStatuses.filter(f => !f.isUntracked && f.workTreeStatus === 'D');
    const added = fileStatuses.filter(f => !f.isUntracked && f.indexStatus === 'A');
    
    // Display files by category
    if (modified.length > 0) {
      console.log('\nüìù Modified files:');
      modified.forEach((file, index) => {
        console.log(`  ${index + 1}. ${file.path}`);
      });
    }
    
    if (untracked.length > 0) {
      console.log('\n‚ùì Untracked files:');
      untracked.forEach((file, index) => {
        console.log(`  ${modified.length + index + 1}. ${file.path}`);
      });
    }
    
    if (added.length > 0) {
      console.log('\n‚ûï Added files:');
      added.forEach((file, index) => {
        console.log(`  ${modified.length + untracked.length + index + 1}. ${file.path}`);
      });
    }
    
    if (deleted.length > 0) {
      console.log('\nüóëÔ∏è  Deleted files:');
      deleted.forEach((file, index) => {
        console.log(`  ${modified.length + untracked.length + added.length + index + 1}. ${file.path}`);
      });
    }

    return await this.promptFileSelection(fileStatuses);
  }

  /**
   * Prompt user to select files for staging
   * @param fileStatuses Array of file statuses
   * @returns Promise<boolean> - true if files were staged, false if cancelled
   */
  private async promptFileSelection(fileStatuses: GitFileStatus[]): Promise<boolean> {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    const question = (prompt: string): Promise<string> => {
      return new Promise((resolve) => {
        rl.question(prompt, resolve);
      });
    };

    try {
      console.log('\nüéØ File selection options:');
      console.log('  ‚Ä¢ Enter file numbers (e.g., 1,3,5 or 1-5)');
      console.log('  ‚Ä¢ Type "all" to stage all files');
      console.log('  ‚Ä¢ Type "modified" to stage only modified files');
      console.log('  ‚Ä¢ Type "untracked" to stage only untracked files');
      console.log('  ‚Ä¢ Press Enter or type "cancel" to cancel');

      const input = await question('\nüìã Select files to stage: ');
      
      if (!input.trim() || input.toLowerCase() === 'cancel') {
        console.log('‚ùå Operation cancelled.');
        return false;
      }

      const selectedFiles = this.parseFileSelection(input, fileStatuses);
      
      if (selectedFiles.length === 0) {
        console.log('‚ùå No valid files selected.');
        return false;
      }

      // Show selected files for confirmation
      console.log('\nüìã Files to be staged:');
      selectedFiles.forEach(file => {
        console.log(`  ‚úì ${file.path} (${file.statusDescription})`);
      });

      const confirm = await question('\n‚ùì Stage these files? (Y/n): ');
      
      if (confirm.toLowerCase() === 'n' || confirm.toLowerCase() === 'no') {
        console.log('‚ùå Staging cancelled.');
        return false;
      }

      // Stage selected files
      console.log('\nüì¶ Staging selected files...');
      for (const file of selectedFiles) {
        this.git.addFile(file.path);
      }

      console.log(`‚úÖ Successfully staged ${selectedFiles.length} file(s).`);
      return true;

    } finally {
      rl.close();
    }
  }

  /**
   * Parse user input for file selection
   * @param input User input string
   * @param fileStatuses Array of file statuses
   * @returns Array of selected files
   */
  private parseFileSelection(input: string, fileStatuses: GitFileStatus[]): GitFileStatus[] {
    const trimmedInput = input.trim().toLowerCase();
    
    // Handle special keywords
    if (trimmedInput === 'all') {
      return fileStatuses;
    }
    
    if (trimmedInput === 'modified') {
      return fileStatuses.filter(f => !f.isUntracked && f.workTreeStatus === 'M');
    }
    
    if (trimmedInput === 'untracked') {
      return fileStatuses.filter(f => f.isUntracked);
    }

    // Parse numeric input (e.g., "1,3,5" or "1-5")
    const selectedFiles: GitFileStatus[] = [];
    const parts = input.split(',').map(p => p.trim());
    
    for (const part of parts) {
      if (part.includes('-')) {
        // Handle range (e.g., "1-5")
        const [start, end] = part.split('-').map(n => parseInt(n.trim()));
        if (!isNaN(start) && !isNaN(end)) {
          for (let i = start; i <= end; i++) {
            if (i >= 1 && i <= fileStatuses.length) {
              selectedFiles.push(fileStatuses[i - 1]);
            }
          }
        }
      } else {
        // Handle single number
        const num = parseInt(part);
        if (!isNaN(num) && num >= 1 && num <= fileStatuses.length) {
          selectedFiles.push(fileStatuses[num - 1]);
        }
      }
    }
    
    // Remove duplicates
    return [...new Set(selectedFiles)];
  }

  /**
   * Validate required configuration for the application
   */
  protected validateConfiguration(): void {
    const requiredConfigs = [
      { key: 'openai.key', name: 'OpenAI API Key' },
      { key: 'openai.baseUrl', name: 'OpenAI Base URL' },
      { key: 'openai.model', name: 'OpenAI Model' },
    ];

    const missing: string[] = [];

    for (const config of requiredConfigs) {
      const value = getConfigValue(this.config, config.key, '');
      if (!value) {
        missing.push(config.name);
      }
    }

    // Validate Git access token for current repository
    try {
      getGitAccessTokenForCurrentRepo(this.config, this.git);
    } catch (error) {
      missing.push('Git Access Token for current repository');
      console.error(`‚ùå ${error instanceof Error ? error.message : 'Unknown Git token error'}`);
    }

    if (missing.length > 0) {
      console.error(`‚ùå Missing required configuration: ${missing.join(', ')}`);
      console.error(`üí° Please run 'aiflow init' to configure or check your config files`);
      process.exit(1);
    }

    console.log(`‚úÖ Configuration validation passed`);
  }

  /**
   * Create automated merge request from staged changes
   */
  async run(): Promise<void> {
    console.log(`üöÄ AIFlow Tool`);
    console.log(`üìÅ Working directory: ${process.cwd()}`);
    console.log(`‚è∞ Started at: ${new Date().toISOString()}`);
    console.log('‚îÄ'.repeat(50));

    try {
      // Step 1: Check for staged changes
      let diff = this.git.getDiff();
      let changedFiles = this.git.getChangedFiles();
      
      if (!diff) {
        console.log("üìã No staged changes found. Let's select files to stage...");
        
        // Interactive file selection
        const filesStaged = await this.interactiveFileSelection();
        
        if (!filesStaged) {
          console.log("‚ùå No files were staged. Exiting...");
          process.exit(1);
        }
        
        // Re-check for staged changes after interactive selection
        diff = this.git.getDiff();
        changedFiles = this.git.getChangedFiles();
        
        if (!diff) {
          console.error("‚ùå Still no staged changes found. Please check your selection.");
          process.exit(1);
        }
        
        console.log(`‚úÖ Successfully staged ${changedFiles.length} file(s). Continuing...`);
      }

      // Step 2: Determine target branch
      const targetBranch = this.getTargetBranch();
      console.log(`üéØ Target branch: ${targetBranch}`);

      // Step 3: Generate commit message and branch name using AI
      console.log(`ü§ñ Generating commit message and branch name...`);
      const { commit, branch } = await this.openai.generateCommitAndBranch(diff);

      console.log("‚úÖ Generated commit message:", commit);
      console.log("‚úÖ Generated branch suggestion:", branch);

      // Step 4: Create branch name
      const gitUser = this.git.getUserName();
      const aiBranch = StringUtil.sanitizeBranch(branch);
      const dateSuffix = new Date().toISOString().slice(0, 19).replace(/-|T|:/g, "");
      const branchName = `${gitUser}/${aiBranch}-${dateSuffix}`;
      console.log("‚úÖ Generated branch name:", branchName);

      // Step 5: Commit and push
      console.log(`üì§ Creating branch and pushing changes...`);
      this.git.commitAndPush(branchName, commit);

      // Step 6: Create Merge Request
      console.log(`üìã Creating Merge Request...`);
      const squashCommits = getConfigValue(this.config, 'git.squashCommits', true);
      const removeSourceBranch = getConfigValue(this.config, 'git.removeSourceBranch', true);

      const mrUrl = await this.gitPlatform.createMergeRequest(
        branchName,
        targetBranch,
        commit,
        squashCommits,
        removeSourceBranch
      );
      console.log(`üéâ ${this.gitPlatform.getPlatformName() === 'github' ? 'Pull Request' : 'Merge Request'} created:`, mrUrl);

      // Step 7: Send notification
      if (getConfigValue(this.config, 'wecom.enable', false) && getConfigValue(this.config, 'wecom.webhook', '')) {
        console.log(`üì¢ Sending notification...`);
        await this.wecom.sendMergeRequestNotice(branchName, targetBranch, mrUrl, commit, changedFiles);
        console.log("üì¢ Notification sent via WeCom webhook.");
      }

      console.log(`‚úÖ AIFlow workflow completed successfully!`);

      // Step 8: Print the MR info and copy to clipboard
      // Format MR information for sharing
      const isGitHub = this.gitPlatform.getPlatformName() === 'github';
      const requestType = isGitHub ? 'Pull Request' : 'Merge Request';
      const requestAbbr = isGitHub ? 'PR' : 'MR';

      const outputMrInfo = `üéâ ${requestType}ÂàõÂª∫ÊàêÂäüÔºåËØ∑ÂèäÊó∂ËøõË°å‰ª£Á†ÅÂÆ°Êü•ÔºÅ
üìã ${requestAbbr} ÈìæÊé•: ${mrUrl}
üìù Êèê‰∫§‰ø°ÊÅØ:
${commit}
üåø ÂàÜÊîØ‰ø°ÊÅØ: ${branchName} ->  ${targetBranch}
üìÅ ÂèòÊõ¥Êñá‰ª∂ (${changedFiles.length} ‰∏™)${changedFiles.length > 10 ? `Ââç10‰∏™: ` : ': '}
${changedFiles.slice(0, 10).map(file => `‚Ä¢ ${file}`).join('\n')}${changedFiles.length > 10 ? `\n...${changedFiles.length - 10}‰∏™Êñá‰ª∂` : ''}`;
      const consoleMrInfo = `
${'-'.repeat(50)}
${outputMrInfo}
${'-'.repeat(50)}
`;
      console.log(consoleMrInfo);
      await clipboard.write(outputMrInfo);
      console.log("üìã MR info copied to clipboard.");
    } catch (error) {
      console.error(`‚ùå Error during MR creation:`, error);
      process.exit(1);
    }
  }

}

/**
 * Git Auto MR application for automated merge request creation
 */
export class GitAutoMrApp extends BaseAiflowApp {


  /**
   * Display usage information
   */
  static showUsage(): void {
    console.log(`
üîß AIFlow Tool

Usage:
  aiflow [init] [options]

Commands:
  init                   ‰∫§‰∫íÂºèÈÖçÁΩÆÂàùÂßãÂåñ
  init --global, -g      ÂàùÂßãÂåñÂÖ®Â±ÄÈÖçÁΩÆ
  
Options:
  --config-help          ÊòæÁ§∫ CLI ÈÖçÁΩÆÈÄâÈ°πÂ∏ÆÂä©
  --help, -h             ÊòæÁ§∫Ê≠§Â∏ÆÂä©‰ø°ÊÅØ
  
Configuration Options (ÂèØ‰ª•ÈÄöËøá CLI ÂèÇÊï∞Ë¶ÜÁõñÈÖçÁΩÆÊñá‰ª∂):
  -ok, --openai-key <key>               OpenAI API ÂØÜÈí•
  -obu, --openai-base-url <url>         OpenAI API Âú∞ÂùÄ
  -om, --openai-model <model>           OpenAI Ê®°Âûã
  -gat, --git-access-token <host=token> Git ËÆøÈóÆ‰ª§Áâå (Ê†ºÂºè: ‰∏ªÊú∫Âêç=‰ª§Áâå)
  -crbu, --conan-remote-base-url <url>  Conan ‰ªìÂ∫ì API Âú∞ÂùÄ
  -crr, --conan-remote-repo <repo>      Conan ‰ªìÂ∫ìÂêçÁß∞
  -ww, --wecom-webhook <url>            ‰ºÅ‰∏öÂæÆ‰ø° Webhook Âú∞ÂùÄ
  -we, --wecom-enable <bool>            ÂêØÁî®‰ºÅ‰∏öÂæÆ‰ø°ÈÄöÁü•
  -sc, --squash-commits <bool>          ÂéãÁº©Êèê‰∫§
  -rsb, --remove-source-branch <bool>   Âà†Èô§Ê∫êÂàÜÊîØ

Description:
  ‰ΩøÁî® AI ÁîüÊàêÁöÑÊèê‰∫§‰ø°ÊÅØÂíåÂàÜÊîØÂêçÁß∞Ëá™Âä®ÂàõÂª∫ÂêàÂπ∂ËØ∑Ê±Ç

Prerequisites:
  1. ÊöÇÂ≠òÊÇ®ÁöÑÊõ¥Êîπ: git add .
  2. ÈÖçÁΩÆÂøÖË¶ÅÂèÇÊï∞: aiflow init ÊàñÊâãÂä®ÂàõÂª∫ÈÖçÁΩÆÊñá‰ª∂

ÈÖçÁΩÆÊñá‰ª∂‰ΩçÁΩÆ (Êåâ‰ºòÂÖàÁ∫ßÊéíÂ∫è):
  1. ÂëΩ‰ª§Ë°åÂèÇÊï∞ (ÊúÄÈ´ò‰ºòÂÖàÁ∫ß)
  2. .aiflow/config.yaml (Êú¨Âú∞ÈÖçÁΩÆ)
  3. ~/.config/aiflow/config.yaml (ÂÖ®Â±ÄÈÖçÁΩÆ)
  4. ÁéØÂ¢ÉÂèòÈáè (ÊúÄ‰Ωé‰ºòÂÖàÁ∫ß)

Auto-Detection Features:
  ‚úÖ Git ÊâòÁÆ°Âπ≥Âè∞È°πÁõÆ ID ‰ªé git remote URL Ëá™Âä®Ê£ÄÊµã (ÊîØÊåÅ HTTP/SSH)
  ‚úÖ Git ÊâòÁÆ°Âπ≥Âè∞ base URL ‰ªé git remote URL Ëá™Âä®Ê£ÄÊµã
  ‚úÖ ÁõÆÊ†áÂàÜÊîØËá™Âä®Ê£ÄÊµã (main/master/develop)
  ‚úÖ Git ËÆøÈóÆ‰ª§ÁâåÂü∫‰∫éÂΩìÂâç‰ªìÂ∫ì‰∏ªÊú∫ÂêçËá™Âä®ÈÄâÊã©

Workflow:
  1. ÂàÜÊûêÊöÇÂ≠òÁöÑÊõ¥Êîπ
  2. ÁîüÊàê AI Êèê‰∫§‰ø°ÊÅØÂíåÂàÜÊîØÂêçÁß∞
  3. ÂàõÂª∫Âπ∂Êé®ÈÄÅÊñ∞ÂàÜÊîØ
  4. ÂàõÂª∫ÂêàÂπ∂ËØ∑Ê±Ç
  5. ÂèëÈÄÅ‰ºÅ‰∏öÂæÆ‰ø°ÈÄöÁü•

Examples:
  aiflow init                                            # ‰∫§‰∫íÂºèÂàùÂßãÂåñÊú¨Âú∞ÈÖçÁΩÆ
  aiflow init --global                                   # ‰∫§‰∫íÂºèÂàùÂßãÂåñÂÖ®Â±ÄÈÖçÁΩÆ
  aiflow                                                 # ‰ΩøÁî®ÈÖçÁΩÆÊñá‰ª∂ËøêË°å
  aiflow -ok sk-123 -gat github.com=ghp_456             # ‰ΩøÁî® CLI ÂèÇÊï∞Ë¶ÜÁõñÈÖçÁΩÆ
  aiflow -gat gitlab.example.com=glpat-456 -we true     # Â§öÂπ≥Âè∞ËÆøÈóÆ‰ª§ÁâåÈÖçÁΩÆ
`);
  }

  /**
   * Main entry point for command line execution
   */
  static async main(): Promise<void> {
    const args = process.argv.slice(2);

    // Handle init command
    if (args.includes('init')) {
      const isGlobal = args.includes('--global') || args.includes('-g');
      await initConfig(isGlobal);
      return;
    }

    // Show CLI help
    if (args.includes('--config-help')) {
      console.log(getCliHelp());
      process.exit(0);
    }

    // Show usage if help requested
    if (args.includes('--help') || args.includes('-h')) {
      GitAutoMrApp.showUsage();
      process.exit(0);
    }

    // Parse CLI configuration arguments
    const cliConfig = parseCliArgs(args);

    const app = new GitAutoMrApp();

    // Initialize services with configuration
    await app.initializeServices(cliConfig);

    // Validate configuration before starting
    app.validateConfiguration();

    // Run the MR creation workflow
    await app.run();
  }
}

// Only run if this file is executed directly
const isMain = path.basename(fileURLToPath(import.meta.url)).toLowerCase() === path.basename(process.argv[1]).toLowerCase();
if (isMain) {
  GitAutoMrApp.main().catch((error) => {
    console.error('‚ùå Unhandled error:', error);
    process.exit(1);
  });
}